{% extends "base.html" %}

{% block title %}Logs - Kessel Run{% endblock %}

{% block page_title %}System Logs{% endblock %}

{% block header_actions %}
<div class="log-controls">
    <button class="btn btn-secondary" id="pause-btn" onclick="togglePause()">
        <span id="pause-icon">‚è∏Ô∏è</span> Pause
    </button>
    <button class="btn btn-secondary" onclick="clearLogs()">
        üóëÔ∏è Clear
    </button>
    <a href="/api/logs/download" class="btn btn-secondary" download>
        üì• Download
    </a>
</div>
{% endblock %}

{% block content %}
<div class="card log-card">
    <div class="card-header">
        <h3>Real-time Log Stream</h3>
        <div class="connection-status" id="connection-status">
            <span class="status-dot disconnected"></span>
            <span class="status-text">Disconnected</span>
        </div>
    </div>
    
    <div class="log-container" id="log-container">
        <div class="log-content" id="log-content">
            <div class="log-line log-info">Connecting to log stream...</div>
        </div>
    </div>
    
    <div class="log-footer">
        <span id="line-count">0 lines</span>
        <label class="checkbox-label">
            <input type="checkbox" id="auto-scroll" checked>
            <span>Auto-scroll</span>
        </label>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    let socket = null;
    let isPaused = false;
    let lineCount = 0;
    const maxLines = 1000;
    
    document.addEventListener('DOMContentLoaded', initLogStream);
    
    function initLogStream() {
        socket = io();
        
        socket.on('connect', () => {
            updateConnectionStatus(true);
            socket.emit('start_log_stream');
        });
        
        socket.on('disconnect', () => {
            updateConnectionStatus(false);
        });
        
        socket.on('connected', (data) => {
            addLogLine('[System] ' + data.status, 'info');
        });
        
        socket.on('log_line', (data) => {
            if (!isPaused) {
                addLogLine(data.line, getLogLevel(data.line), data.historical);
            }
        });
        
        socket.on('log_error', (data) => {
            addLogLine('[Error] ' + data.error, 'error');
        });
        
        socket.on('stream_status', (data) => {
            addLogLine('[System] Stream ' + data.status, 'info');
        });
    }
    
    function updateConnectionStatus(connected) {
        const statusEl = document.getElementById('connection-status');
        const dot = statusEl.querySelector('.status-dot');
        const text = statusEl.querySelector('.status-text');
        
        if (connected) {
            dot.className = 'status-dot connected';
            text.textContent = 'Connected';
        } else {
            dot.className = 'status-dot disconnected';
            text.textContent = 'Disconnected';
        }
    }
    
    function getLogLevel(line) {
        if (line.includes('[ERROR]') || line.includes('ERROR')) return 'error';
        if (line.includes('[WARNING]') || line.includes('WARNING')) return 'warning';
        if (line.includes('[INFO]') || line.includes('INFO')) return 'info';
        if (line.includes('[DEBUG]') || line.includes('DEBUG')) return 'debug';
        return 'default';
    }
    
    function addLogLine(text, level = 'default', historical = false) {
        const container = document.getElementById('log-content');
        const line = document.createElement('div');
        line.className = `log-line log-${level}`;
        if (historical) line.classList.add('historical');
        
        // Escape HTML and preserve formatting
        line.textContent = text;
        
        container.appendChild(line);
        lineCount++;
        
        // Limit total lines
        while (container.children.length > maxLines) {
            container.removeChild(container.firstChild);
        }
        
        // Auto-scroll if enabled
        if (document.getElementById('auto-scroll').checked) {
            const logContainer = document.getElementById('log-container');
            logContainer.scrollTop = logContainer.scrollHeight;
        }
        
        // Update line count
        document.getElementById('line-count').textContent = `${lineCount} lines`;
    }
    
    function togglePause() {
        isPaused = !isPaused;
        const btn = document.getElementById('pause-btn');
        const icon = document.getElementById('pause-icon');
        
        if (isPaused) {
            icon.textContent = '‚ñ∂Ô∏è';
            btn.innerHTML = '<span id="pause-icon">‚ñ∂Ô∏è</span> Resume';
            addLogLine('[System] Log stream paused', 'info');
        } else {
            icon.textContent = '‚è∏Ô∏è';
            btn.innerHTML = '<span id="pause-icon">‚è∏Ô∏è</span> Pause';
            addLogLine('[System] Log stream resumed', 'info');
        }
    }
    
    async function clearLogs() {
        if (!confirm('Clear all logs? This cannot be undone.')) return;
        
        try {
            await apiCall('/api/logs/clear', 'POST');
            
            // Clear the display
            const container = document.getElementById('log-content');
            container.innerHTML = '';
            lineCount = 0;
            document.getElementById('line-count').textContent = '0 lines';
            
            addLogLine('[System] Logs cleared', 'info');
            showToast('Logs cleared', 'success');
        } catch (error) {
            showToast(error.message, 'error');
        }
    }
    
    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
        if (socket) {
            socket.emit('stop_log_stream');
            socket.disconnect();
        }
    });
</script>
{% endblock %}

